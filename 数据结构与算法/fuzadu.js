/*
 * @Author: your name
 * @Date: 2020-12-15 09:41:19
 * @LastEditTime: 2020-12-28 10:33:19
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: \learn\数据结构与算法\fuzadu.js
 */
//时间复杂度空间复杂度

//时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
//空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

//简而言之，就是你使用的for循环越多，那么你的时间复杂度就越大，你声明的变量越多那么你的空间复杂度就越大


//表示方法
//目前行业中公认叫做「 大O符号表示法 」

//时间复杂度量级

//常数阶O(1)
//线性阶O(n)
//对数阶O(logN)
//线性对数阶O(nlogN)
//平方阶O(n²)
//立方阶O(n³)
//K次方阶O(n^k)
//指数阶(2^n)


//1.常数阶O(1)
//无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)
// int i = 1;
// int j = 2;
// ++i;
// j++;
// int m = i + j;
//上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度

//2.线性阶O(n)
// 这个在最开始的代码示例中就讲解过了，如：
// for(i=1; i<=n; ++i)
// {
//    j = i;
//    j++;
// }
// 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

// 3.对数阶O(logN)
// int i = 1;
// while(i<n)
// {
//     i = i * 2;
// }
// 从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。
// 我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
// 也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)

// 4.线性对数阶O(nlogN)
// 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。
// 就拿上面的代码加一点修改来举例：
// for(m=1; m<n; m++)
// {
//     i = 1;
//     while(i<n)
//     {
//         i = i * 2;
//     }
// }

// 5.平方阶O(n²)
// 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
// 举例：
// for(x=1; i<=n; x++)
// {
//    for(i=1; i<=n; i++)
//     {
//        j = i;
//        j++;
//     }
// }
// 这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²) 


// 立方阶O(n³)、K次方阶O(n^k)
// 参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。



//空间复杂度
//空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义

//空间复杂度比较常用的有：O(1)、O(n)、O(n²)

//1.空间复杂度 O(1)
// 如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
// int i = 1;
// int j = 2;
// ++i;
// j++;
// int m = i + j;
// 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)