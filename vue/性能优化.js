// 1、减少请求数量
// 合并文件 、  图片处理（雪碧图、icon代替图片）、减少重定向（301永久重定向）、不使用css@import、避免使用空的src和href
// 2、减小资源大小
// html、css、js、图片的压缩
// 3、优化网络连接
// 使用CDN内容分发（根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，使用户可就近取得所需内容）
// 4、优化资源下载
// 资源加载位置（css放在head中，先外链后本页，js放在body底部，先外链后本页）
// 资源加载时机（按需加载，懒加载（延迟加载）、预加载（浏览空闲的时候））
// 5、减少重绘回流
// 避免使用层级较深的选择器，不使用table（一个小改动，table大约渲染要3倍同级计元素的时间）
// 元素适量的定义高度或者是最小高度，动态载入时，会出现晃动，造成回流
// 图片也是一样的，给设置尺寸，首次载入时，上下左右都可能发生位移，造成回流
// DOM优化（缓存DOM，减少DOM深度和DOM数量，批量操作DOM，事件代理，防抖和节流，及时清理环境（消除对象的引用，清除定时器，消除事件监听））
// 6、性能更好地API
// 用对选择器（id、类、标签、相邻、子、后代、通配符、属性、伪类）
// 7、webpack优化
// 打包公共代码
// 动态导入和按需加载
// 剔除无用代码     

// 性能优化：
// 1. 传输方面：可以启用gzip压缩提高传输效率
// 2. js模块化方面：使用requirejs的前端模块化方案，可以使用webpack进行打包压缩，使用esModule方案，有利于浏览器优化
// 3. 缓存方面：全部使用的协商缓存，每次静态资源请求都会走到服务器进行验证，无疑增加服务器压力，可以考虑部分使用浏览器强缓存没设置过期时间

// 一个页面从生命周期的维度主要分为三个阶段：加载阶段、交互阶段、关闭阶段。
// 1. 加载阶段影响网页首次渲染的关键资源几个指标：个数、大小、RTT（round trip time）。通常一个HTTP的数据包在14kb左右。
// 2. 交互阶段的优化主要是指渲染进程渲染帧速度。如何让单个帧生成的速度变快呢？ 
// * 减少JavaScript脚本执行时间
//  * 避免强制同步布局，添加 删除dom后计算样式布局是在另外一个任务中执行的，这时候获取样式信息，会将其变成同步任务。 
// * 避免布局抖动
//  * 合理利用CSS合成动画（标识 will-change 单独生成一个图层） 
// * 避免频繁的垃圾回收。（尽量避免临时垃圾数据，优化存储结构，避免小颗粒对象产生）

// 1.可以通过文件打包的形式减少 HTTP 请求数量，这样对于文件的大小来说，可以减小文件体积。
// 2.也可以压缩代码，以及选择更合适的图片格式，这些都可以让我们加载更小的文件。
// 3.图片的懒加载和路由的懒加载可以让首页加载更少的文件，从而实现页面整体性能的优化。
// 4.用户体验优化这一部分，我们的关注点是在交互体验的优化上。有些场景我们可以损失部分性能去换取体验的提升，比如通过骨架图，我们可以在页面加载之前，通过对图片预先加载出模糊版本，可以让用户获得更好的体验。
// 5.在性能监测报告这一部分，我讲到选择合适的工具，可以帮助我们实时地监测项目的性能。我们通过 Lighthouse 性能报告和 Performace 监测工具，可以精确地定位到项目瓶颈所在，有针对地去进行性能优化。

// 所以要想缩短白屏时长，可以有以下策略：
// 1。通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
// 2.但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
// 3.还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
// 4.对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。